âœ… Introduction to Memory Management
In a multiprogramming environment, the OS needs to manage multiple processes in main memory to keep the CPU busy and ensure that the system is responsive. Since memory is shared by several processes, we need a way to manage it efficiently and safely. Thatâ€™s where memory management comes inâ€”it helps allocate memory to processes, keeps them isolated, and prevents one process from interfering with another.

âœ… Logical vs Physical Address
The logical address is the address generated by the CPUâ€”itâ€™s what the user or program sees. However, this logical address is not the real location in physical memory. The physical address refers to the actual place in RAM where data or instructions are stored.

This translation from logical to physical address is done by a hardware component called the Memory Management Unit (MMU). So, users only deal with logical addresses, while the MMU maps them to physical addresses behind the scenes.

âœ… Memory Mapping and Protection
To protect memory and isolate processes, the OS uses a virtual address space and hardware registers like the relocation register and limit register. The relocation register holds the starting physical address (base), and the limit register defines the range the process is allowed to access.

During a context switch, the OS updates these registers for the new process. If any process tries to access memory outside its allowed range, the system raises a trap and stops that processâ€”this ensures security and memory safety.

âœ… Memory Allocation Methods
There are two main types of memory allocation:

Contiguous Allocation

Non-contiguous Allocation

Letâ€™s focus on Contiguous Allocation here.

âœ… Contiguous Memory Allocation
In contiguous allocation, each process gets a single, continuous block of memory. There are two main types:

ðŸ”¹ Fixed Partitioning
Memory is divided into fixed-sized blocks or partitions.

Processes are loaded into available partitions.

Problems with fixed partitioning:

Internal fragmentation: If a process is smaller than the partition, the leftover space is wasted.

External fragmentation: Free memory exists but is scattered, making it unusable for larger processes.

Process size limitation: If a process is larger than any partition, it canâ€™t be loaded.

Low degree of multiprogramming: The number of processes is limited by the number of partitions.

ðŸ”¹ Dynamic Partitioning
Partitions are created dynamically based on process size.

No fixed partition sizes, so it adjusts based on need.

Benefits:

No internal fragmentation.

No restriction on process size.

Higher degree of multiprogramming.

Drawback:

Still suffers from external fragmentation, since free memory gets scattered.

âœ… Free Space Management
To deal with external fragmentation, the OS uses compaction (or defragmentation). This process shifts processes to one side and merges all free spaces into a large, contiguous block. Although it helps load bigger processes, compaction is slow and affects system performance.

The OS keeps track of free memory using a free list, often implemented as a linked list of holes (free memory blocks). When a process requests memory, the OS uses different algorithms to choose a hole:

ðŸ”¹ Allocation Algorithms:
First Fit: Allocates the first hole that fits. Itâ€™s fast and simple.

Next Fit: Similar to first fit but starts from where the last allocation happened.

Best Fit: Finds the smallest hole that fits. Reduces internal waste but can create many tiny holes, leading to external fragmentation.

Worst Fit: Picks the largest hole. May reduce fragmentation but is slow and often inefficient.

