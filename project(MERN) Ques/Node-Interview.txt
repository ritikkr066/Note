1.Explain Asychronous and Non-blocking programming?
   In Node.js, asynchronous and non-blocking mean that tasks don’t wait for each other. For example, if I read a file, Node.js doesn’t stop — it continues with the next task, and when the file is ready, it gives me the result. This makes Node.js very efficient for handling multiple requests at the same time

2. What is the Event Loop in Node.js?
    The Event Loop is the heart of Node.js. Since Node.js runs on a single thread, it uses the Event Loop to manage all asynchronous operations. Instead of blocking and waiting (like reading a file or calling an API), Node.js hands that work to the system and continues doing other tasks. When the work is finished, the Event Loop makes sure the result or callback runs.

    console.log("Start");

    setTimeout(() => {
    console.log("Inside setTimeout");
    }, 2000);

    console.log("End");

    When this code runs, Node.js first prints “Start”, then schedules the setTimeout function to run after 2 seconds. It doesn’t wait — it immediately prints “End”. After 2 seconds, the Event Loop picks up the setTimeout callback and executes it, printing “Inside setTimeout”.

3. What is middleware in Express.js?
   In Express.js, middleware is basically a function that sits between the request and the response.

    When a request comes to your server, middleware can:
        Look at the request (like check if the user is logged in, log details, parse JSON, etc.).
        Decide whether to continue to the next middleware/route or stop and send a response.

    eg.  app.use()

    When to Use Middleware
        -> Logging: Track incoming requests (e.g., using morgan).
        -> Authentication: Validate user credentials.
        -> Validation: Check and sanitize request data.
        -> Error Handling: Manage errors gracefully.
        -> Static File Serving: Serve files like images, CSS, etc. (e.g., express.static).

4. How does Node.js handle child Threads ?
    Node.js runs JavaScript code in a single thread but it doesn’t mean Node.js is fully single-threaded. Node.js uses a C++ library called libuv, which provides a thread pool. When you perform heavy tasks like file I/O, crypto, or compression, Node.js offloads those task  to child threads in that pool, so the main event loop remains free and non-blocking. Once the child thread finishes, the result is passed back to the main thread through a callback or a promise. This is how Node.js achieves concurrency without blocking the event loop.”

    Aspect	        Child Processes	                                            Worker Threads
    Definition	    Independent processes with their own memory.	            Threads within the same process sharing memory.
    Use Case	    Suitable for running separate applications or scripts.	    Ideal for CPU-intensive tasks within the same application.
    Memory Sharing	No memory sharing; each process has its own memory.	        Shares memory with the main thread 
    Communication	Uses inter-process communication (IPC).	                    Uses message passing (via MessagePort).

5. What are Streams in Node.js?
   Streams in Node.js are objects that let us read or write data piece by piece, instead of loading the whole data into memory at once. They are especially useful when dealing with large files or continuous data, like reading a video or sending logs over a network. For example, instead of reading a 1GB file fully, a stream will read it in small chunks, process them, and keep memory usage low. Node.js has four main types of streams: Readable, Writable, Duplex, and Transform.

    Types of Streams
        1. Readable Streams: Used to read data (e.g., fs.createReadStream for reading files).
        2. Writable Streams: Used to write data (e.g., fs.createWriteStream for writing files).
        3. Duplex Streams: Both readable and writable (e.g., network sockets).
        4. Transform Streams: A type of duplex stream that modifies or transforms data as it is read or written (e.g., zlib.createGzip for compression).
    
6. What is  Callback hell and how can fix it?
    Callback Hell happens in Node.js when we have too many nested callbacks, usually in asynchronous code.

    Fix callback hell in node.js:-

    1. use Promises

        // Without Promises (Callback Hell)
        asyncOperation1((err, result1) => {
        asyncOperation2(result1, (err, result2) => {
            asyncOperation3(result2, (err, result3) => {
            console.log(result3);
            });
        });
        });

        // With Promises
        asyncOperation1()
        .then(result1 => asyncOperation2(result1))
        .then(result2 => asyncOperation3(result2))
        .then(result3 => console.log(result3))
        .catch(err => console.error(err));
    
    2. Use Async/Await
        async function processOrder(id) {
            try {
                const user = await getUser(id);
                const orders = await getOrders(user.id);
                const details = await getOrderDetails(orders[0]);
                const result = await processPayment(details);
                console.log("Payment processed:", result);
            } catch (err) {
                console.error("Error:", err);
            }
        }
                
    3. Modularize Functions :- Break down nested callbacks into smaller, named functions

7. How do Promises improve callback handling ?
   Promises in Node.js improve callback handling by avoiding deeply nested functions (callback hell). Instead of passing a callback into every function, a Promise represents a value that will be available in the future. This allows us to chain operations using .then() and handle errors with .catch(), making code cleaner, more readable, and easier to maintain.”

8. What is the purpose of package.json?
    The package.json file is the heart of any Node.js project. It stores metadata about the project, such as its name, version, description, author, and most importantly, the list of dependencies and scripts. It ensures that anyone working on the project can install the exact same dependencies with npm install. It also defines custom scripts, like start or test commands, to simplify project execution.”
    Project Metadata → name, version, description, author.
    Dependencies → lists required packages (dependencies and devDependencies).
    Scripts → lets you define custom commands like npm start, npm test.
    Version Control → ensures consistent project setup across environments.

9. What is the difference between process.nextTick() and setImmediate()?
    Both process.nextTick() and setImmediate() schedule callbacks asynchronously, but they run in different phases of the Event Loop.

    Feature	             process.nextTick()	                            setImmediate()
    Execution Timing
    	process.nextTick() :- Executes immediately after the current operation completes(before moving to the next event loop phase).	
        setImmediate():- Executes in the check phase of the event loop, after I/O operations.        

     Priority
        process.nextTick():- Higher priority. It runs before any I/O events or timers.
       	setImmediate():- Lower priority. Runs after I/O events and before setTimeout() callbacks.

        
    Use Case
    	process.nextTick():- For tasks that need to execute immediately after the current operation (high-priority microtasks).	
        setImmediate():- For tasks that should run after I/O operations but with lower priority than process.nextTick().

10. How can you handle errors in Node.js ?
    Error handling in Node.js is important to ensure that our application runs smoothly and can recover from unexpected issues

    Handling ways:-
        -> Try-catch block
        -> Promises :- then-catch
        -> Asychronous callback 
