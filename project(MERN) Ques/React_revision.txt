1. what is npm? 
    npm stands for Node Package Manager.
    npm like a Play Store for JavaScript libraries. Instead of building everything from scratch, you just â€œdownloadâ€ packages you need using npm.

2. what is node modules? 
    It contains all the actual code of the libraries (dependencies) your project needs.

3. what is public in react.js
    This folder contains static files â€” things that donâ€™t change when your React app runs.
    Images, logos, icons, or any static files you donâ€™t want Webpack/Vite to process.
    Use it for static assets that donâ€™t need importing into React.

4. diff b/w index.css and app.css?
    index.css
        A global stylesheet.
        Imported in index.js (or main.jsx in Vite).
        Styles here apply to the entire app, unless overridden.
    
    app.css
        A component-specific stylesheet.
        Usually imported only inside App.js.
        Styles here are mostly used for the App component and its children.

5. What is ReactDOM ?
    ReactDOM is a package that provides DOM-specific methods for React.
    It acts as the bridge between React and the actual browser DOM.
    ReactDOM takes your React components (virtual DOM) and renders them into the real DOM.

6. what is package.json? 
    Itâ€™s a configuration file for every Node.js / React project.
    It keeps all the important metadata about your project.

    What it contains:
        Project Info â€“ name, version, description, author
        Scripts â€“ commands you can run (npm start, npm run build, etc.)
        Dependencies â€“ packages your app needs (like react, axios)
    
7. in React, each component must return only 1 parent element.
    or we have to wrap  Use React Fragment (<> ... </>)

8. JSX (JavaScript XML)
    It looks like HTML inside JavaScript, but itâ€™s not exactly HTML.
    <h1> Ritik </h1>
       React (via Babel) converts it into: :  React.createElement("h1","null","Ritik") // type prop  children
       React.createElement builds the Virtual DOM tree.
    
    ğŸ‘‰ Event Bubbling means:
    When an event happens on a child element, it â€œbubbles upâ€ to its parent, then to the parentâ€™s parent, and so on until it reaches the root.

9. JavaScript Expression in JSX  using {}
    <h1> price : {10+2} </h1>

10. preventDefaults() mean
    Itâ€™s a method used to prevent the default behavior of an event in the browser.
    Default behavior = what the browser normally does when that event occurs.

    when form submit : 
        Without preventDefault() â†’ page reloads.
        With preventDefault() â†’ stays on the same page.

11. Event in React.js
    An event is an action that happens in the browser, like a click, change, key press, submit, hover, etc.
     Button click
     function App() {
        const handleClick = () => {
            alert("Button clicked!");
        };

        return <button onClick={handleClick}>Click Me</button>;
    }
    ğŸ‘‰ onClick is the event and handleClick is the handler function.

12. how to pass data from child to parent (i ll study)
    ğŸ”¹ Child â†’ Parent (Data Upward)
        React uses a unidirectional data flow â†’ data normally flows down.
        To send data upward:
        ğŸ‘‰ The parent gives the child a function as a prop.
        ğŸ‘‰ The child calls that function and passes data to it.

13. Spread Operator
    let numbers = [1, 2, 3];
    let newNumber = 4;

    // add number at the end
    numbers = [...numbers, newNumber];

14. What is useEffect?
    useEffect is a React Hook used to run side effects in functional components.
    Side effects = anything that happens outside the normal React render cycle.
    eg. Fetching data from an API

    eg. React LifeCycle
    ğŸ”¹ Example 2: Run Only Once (on Mount)
        useEffect(() => {
            console.log("Component mounted!");
        }, []);  // empty dependency array
        ğŸ‘‰ Runs only when the component first loads. Perfect for fetching data once.
    
    Run When State/Prop Changes
        useEffect(() => {
            console.log("Count changed:", count);
        }, [count]);
        ğŸ‘‰ Runs only when count changes.
    
    Cleanup (Unmount)
        useEffect(() => {
        const interval = setInterval(() => {
            console.log("Timer running...");
        }, 1000);

        return () => {
            clearInterval(interval); // cleanup
            console.log("Timer stopped");
        };
        }, []);
        ğŸ‘‰ Good for cleaning up timers, subscriptions, or event listeners.

    
    ## Fetch Users from API
        // useEffect runs once when the component mounts
        useEffect(() => {
            fetch("https://jsonplaceholder.typicode.com/users")
            .then((res) => res.json())
            .then((data) => {
                setUsers(data);       // save API data in state
                setLoading(false);    // stop loader
            })
            .catch((err) => {
                console.error("Error fetching users:", err);
                setLoading(false);
            });
        }, []); // empty dependency â†’ runs only once
    
        ğŸ”¹ What happens here:
            On first render, useEffect runs because of [].
            It fetches data from API â†’ converts to JSON.
            Stores data in users state.
    
    Fetch Users with async/await
        const fetchUsers = async () => {
            try {
                const response = await fetch("https://jsonplaceholder.typicode.com/users");
                const data = await response.json();
                setUsers(data);        // update state
            } catch (error) {
                console.error("Error fetching users:", error);
            } finally {
                setLoading(false);     // always stop loader
            }
        };

     // run only once on mount
        useEffect(() => {
            fetchUsers();
        }, []);

15 . useMemo
    const sortedNumbers = useMemo(() => {
        console.log("Sorting...");
        return [...numbers].sort((a, b) => a - b);
    }, [numbers]);

        return (
            <div>
            <button onClick={() => setCount(count + 1)}>Re-render ({count})</button>
            <p>First number: {sortedNumbers[0]}</p>
            </div>
        );
    
    What happens here?
        Without useMemo: every time you click the button, sorting runs again (even though numbers didnâ€™t change).
        With useMemo: sorting only runs if numbers changes.
    
    ğŸ”¹ Key Points for Interviews
        useMemo caches values, not functions.
        (If you want to cache functions, use useCallback.)

        It is a performance optimization tool, not a correctness tool.
        Overusing it can hurt performance (because caching itself has a cost).
        ğŸ‘‰ Use it only for expensive calculations.

        It prevents unnecessary recalculations but not unnecessary re-renders.

16. useCallback
    const handleClick = useCallback(() => {
        console.log("Clicked");
    }, []); // dependency array empty â†’ function will never be recreated

    return (
        <>
        <button onClick={handleClick}>Click</button>
        <button onClick={() => setCount(count + 1)}>Increase: {count}</button>
        </>
    );
    // without useCallback
    Every time count changes, App re-renders â†’ and handleClick is created again in memory.
    If you pass this function down to a child component, it may cause unnecessary re-renders of the child.

    //with useCallback
    Now handleClick is stable â€” it wonâ€™t be recreated on every render.

    ğŸ”¹ Difference Between useMemo and useCallback
        useMemo â†’ memoizes a value (e.g., computed result like sorted array).
        useCallback â†’ memoizes a function.

        ğŸ‘‰ Think like this:
        useMemo gives you cachedValue.
        useCallback gives you cachedFunction.

17. External CSS
    In React (with plain CSS), if you create an external file like App.css and import it in a component:
        import './App.css';
        ğŸ‘‰ All the CSS rules written inside App.css become global to the entire application, not just that one component.
        This is because plain CSS does not have scope â€” once imported, its classes and selectors apply everywhere in the DOM.
    
    .module.css
        //here import is compulsory in each component
        import styles from './App.module.css';
        export default function App() {
        return <h1 className={styles.title}>Hello</h1>;
        }

18. form
    DefaultValue

       const [name, setName] = useState("");
      <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)} // controlled
        />
    
    // single state object for all inputs
        const [formData, setFormData] = useState({
            name: "",
            email: "",
            password: ""
        });
    
    // generic change handler
        const handleChange = (e) => {
           // const { name, value } = e.target;
            setFormData((prev) => ({
            ...prev,           // keep old values
            [e.target.name]: e.target.value      // update the changed field
            }));
        };
        
        <form onSubmit={handleSubmit}>
        <input
          type="text"
          name="name"
          value={formData.name}
          onChange={handleChange}
        />
