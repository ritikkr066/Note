 						Java OOPs
1. we can make infinite number of class in one java file,but there will be only one Public class in it. 
	that public class name should be same as java file name
	eg. mainClass.java

	public class mainClass{
		psvm(){
			//class-> non-primitive data type
			Dog dog=new Dog(); //object of that class 
			dog.name="Tommy";
			dog.walk(); // tommy is walking
		}
	}


-> Classes and Object

	A class is a blueprint or template in object-oriented programming (OOP) that defines the properties (data) and behaviors (functions/methods) of objects

	For example, you can define a class Car with properties like color and speed, and behaviors like start() or brake(). Once a class is defined, you can create multiple objects (instances) from it, each having its own set of values but sharing the same structure. So, a class is like a template, and objects are its real-world usable versions.

	class Dog{  //factory
		String name; //properties
		int age; //properties

		void walk(){  	 // behavior->function
			print(name+"is walking");
		}	
		void eat(){} // behavior
	}
	behaviour->function
	properties-> variable


->	METHOD OVERLOADING
	we can use METHOD OVERLOADING in real time online payment System

	Method 1: Process payment using a credit card with basic details.
	Method 2: Process payment using a debit card with additional CVV.
	Method 3: Process payment using a digital wallet.

	method overloading allows multiple methods with the same name but different parameter lists to coexist in a class
		Method overloading can be achieved by either:-
		a. changing tha data type of argument;
			public int add(int a, int b) {
                 return a + b;
            }
			// Method to add two doubles
            public double add(double a, double b) {
                return a + b;
            }
    
		b. changing the number of argument

				public int multiply(int a, int b) {
                     return a * b;
                }

                // Method to multiply three integers
                public int multiply(int a, int b, int c) {
                     return a * b * c;
                }


	#PseudoCode

	public class PaymentProcessor {

    // Method to process payment using a credit card (basic details)
         public void processPayment(String cardNumber, String expiryDate) {

        }

    // Method to process payment using a credit card (additional CVV)
        public void processPayment(String cardNumber, String expiryDate, String cvv) {
       
    	}

    // Method to process payment using a digital wallet
       public void processPayment(String walletId) {
      
       }
    }

public class Main {
    public static void main(String[] args) {
        PaymentProcessor paymentProcessor = new PaymentProcessor();

        // Processing payment using credit card with basic details
        paymentProcessor.processPayment("1234-5678-9012-3456", "12/24");

        // Processing payment using credit card with CVV
        paymentProcessor.processPayment("1234-5678-9012-3456", "12/24", "123");

        // Processing payment using digital wallet
        paymentProcessor.processPayment("wallet-xyz-123");
    }
}


--> 	CONSTRUCTOR

		Key Points About Constructors
			1. Name: A constructor must have the same name as the class it is in.
			2. No Return Type: Constructors do not have a return type, not even void.
			3. Called Automatically: Constructors are called automatically when an object is created.
			4. Default Constructor: If no constructor is defined, Java provides a default no-argument constructor.
			5. Overloading: Constructors can be overloaded to create objects in different ways.

		--example--
		public class ComplexNumber {
    			private double real; 
    			private double imaginary;

    			// Default constructor
    			public ComplexNumber() {
        			this.real = 0;
        			this.imaginary = 0;
    			}

    			// Parameterized constructor
    			public ComplexNumber(double real, double imaginary) {
        			this.real = real;
        			this.imaginary = imaginary;
    			}

    			// Constructor to initialize only the real part
    			public ComplexNumber(double real) {
        			this.real = real;
        			this.imaginary = 0;
    			}

    			// Method to display the complex number
    			public void display() {
        			System.out.println(real + " + " + imaginary + "i");
    			}
		}

--> this keyword
		Referring to Instance Variables: When local variables and instance variables have the same name,
		 the this keyword is used to refer to the instance variable.

		 public class Java{
			int a,b; // instance variable;
				Java(int a,int b){ // local variable
						this.a=a;  //this.a refer to instance variable
						this.b=b;
				}
		 }

## JAVA INHERITANCE

		PARENT
		  ^
		  |
		  |
		CHILD
		
	-> child inherit from parent

	if start() function present in parent class and same start() function present in child class.In that condition child class function override parent class function and child class function will call.

	Default function of parent is called by itself.

	NOTES:-

	Method Overriding is known as runtime polymorphisim. Hence we can achieve PolyMorphisim in Java with the help of inheritance;
	Method Overloading is known as compile time polymorphisim

	COMPILE_TIME POLYMORPHISM & RUN_TIME POLYMORPHISM

	Method Overloading: This occurs when multiple methods in the same class have the same name but different parameters (different type, number, or both). The compiler determines which method to invoke at compile time.

	Runtime polymorphism is achieved by method overriding. The method to be executed is determined at runtime based on the object's actual class.


--->SUPER Key
	Super key in java refer to the instance of immediate parent class.
	it is used to invoke a method/constructor of immediate parent class 

	* super() must be first statement in constructor body.
	* this() and super() can't be used together an both wanted to be present one above the other.

---> FINAL keyword
	non-access modifier that is used to define entity that cannot be changed or modified

		Final variable:- can't be assigned again
		Final Method:can't be overridden by its subclasses
		Final Class: can't be extended on inherited from another class 

--> PACKAGE in JAVA

	import java.util.Date; // import only Date class
	imprt java.util.io.*;  // import everything inside java.io package

--> JAVA ACCESS MODIFIER
		There are four primary access modifiers:
			public
			protected
			default (no modifier)
			private

		PUBLIC: public class is accessible from any other class.
		PROTECTED: protected member is accessible within its own package (like default) and by subclasses in other packages.
		DEFAULT:  class with no modifier is only accessible within its own package.
		PRIVATE:  private member is accessible only within its own class.

## ENCAPSULATION
		* bundling/combining the data (fields) and methods (functions)  into a single unit called a class
		* It prevents outer class from accessing and changing fields and methods of a class.
		* This also helps to achieve data hiding.

	--> Data Hiding
			Data hiding is a way of restricting the access of our data members by the implementation details.

			NOTE:- Encapsulation can be used to achieve data hiding. Encapsulation in itself in not data hiding.

			Eg. BankAccount.java

	   public class BankAccount {
            // Private fields
            private String accountNumber;
            private double balance;

    		// Constructor to initialize fields
    		public BankAccount(String accountNumber, double balance) {
        		this.accountNumber = accountNumber;
        		this.balance = balance;
    		}

			boolean BANK_SERVER =true;

    		// Getter for accountNumber
    		public String getAccountNumber() {
				if(BANK_SERVER) return accountNumber;
				return new String("Server error);	
    		}
			
    		// Getter for balance
    		public double getBalance() {
				if(BANK_SERVER){
					return balance;
				}
        		return -1.0;
    		}

    		// Method to deposit money
    		public void deposit(double amount) {
        		if (amount > 0) {
            		balance += amount;
        		} else {
            		System.out.println("Invalid deposit amount");
        		}
    		}

    		// Method to withdraw money
    		public void withdraw(double amount) {
        		if (amount > 0 && amount <= balance) {
            		balance -= amount;
        		} else {
            		System.out.println("Invalid withdraw amount or insufficient balance");
        	}
    	}
	}


	//main function to call this program

	public class Main {
    	public static void main(String[] args) {
        	// Create a new BankAccount object
        	BankAccount account = new BankAccount("123456789", 500.0);

        	// Accessing fields using getter methods
       		System.out.println("Account Number: " + account.getAccountNumber());
        	System.out.println("Initial Balance: " + account.getBalance());

        	// Deposit money
        	account.deposit(200.0);

        	// Withdraw money
        	account.withdraw(100.0);
        	// Attempt to withdraw more money than the current balance
        	account.withdraw(700.0);
    	}
	}

--> The STATIC keyword
		If we want to create class members without creating an instance of the class,We need to declare the class member STATIC
		* Static variables are class variable and are shared among all the class instance

		Static Variables:
				* only a single copy of static variable is created and shared among all instance of the class.
				* Because it is Class-level variable, memeory allocation of such variable only happen once when the class is loaded in 	  the memory 
				* static variable can be used in any type of method: static or non-static,
				* Non-static cannot be used inside static methods. it will throw a compile-time error.

		Static Methods:
				The keyword such as this and super are not used in the body of the static method.

## Abstract class
	An abstract class is a class that cannot be instantiated on its own.
				or,
	An abstract class is a class you canâ€™t create objects from directly.

	#Key Points
		1.Cannot be Instantiated: You cannot create an object of an abstract class directly. You need to subclass it and instantiate the subclass.
		eg.

		abstract class Animal {
    		// Abstract class can't be instantiated
		}

		// Animal animal = new Animal(); // This would cause a compile-time error

		2. Abstract Methods: An abstract class can have abstract methods. These are methods that are declared without an implementation (i.e., no method body). Subclasses must override and provide implementations for all abstract methods.
		eg.

		abstract class Animal {
    		abstract void sound(); // Abstract method
		}

		class Dog extends Animal {
    		void sound() {
        	System.out.println("Bark");
    		}
		}

		3.Constructors: Abstract classes can have constructors, which are invoked when an instance of a subclass is created.
		eg.

		abstract class Animal {
    		Animal() {
        		System.out.println("Animal is created");
    		}
		}

		class Dog extends Animal {
    		Dog() {
       		 	System.out.println("Dog is created");
    		}
		}


		4.Inheritance: A subclass that extends an abstract class must implement all the abstract methods of the parent class unless the subclass is also declared abstract.

		5.Multiple Inheritance: Java does not support multiple inheritance (i.e., extending more than one class), but an abstract class can implement multiple interfaces.


		eg. of abstract class 

		abstract class Vehicle {
    		abstract void start();  // Abstract method
    
    		void stop() {           // Concrete method
       			 System.out.println("Vehicle stopped");
    		}
		}

		class Car extends Vehicle {
    		void start() {          // Implementing abstract method
        		System.out.println("Car started");
    		}
		}

		public class Main {
    		public static void main(String[] args) {
        		Vehicle myCar = new Car();
        		myCar.start();      // Output: Car started
        		myCar.stop();       // Output: Vehicle stopped
    		}
		}
	
	**When you want to provide a common base class for related classes.we use Abstract class

##Abstraction

	 Abstraction is the process of hiding the implementation details of an object and exposing only the essential features or functionalities.
					or,
	Abstraction hides details and shows only important features of an object.

	 * Abstraction allows you to define the behavior of an object without worrying about its internal implementation.

	  For eg. you can define an interface Payment with a method processPayment(). Different classes, such as CreditCardPayment and PayPalPayment, can implement this interface and provide their own implementation of the processPayment() method.

	  //PseudoCode

	    interface Payment {
    		void processPayment(double amount);
	    }

		class CreditCardPayment implements Payment {
    		public void processPayment(double amount) {
        		System.out.println("Processing credit card payment of $" + amount);
    		}
		}

		class PayPalPayment implements Payment {
    		public void processPayment(double amount) {
        		System.out.println("Processing PayPal payment of $" + amount);
    		}
		}

	#Abstract Class: A class can inherit from only one abstract class (single inheritance).
	#Interface: A class can implement multiple interfaces (multiple inheritance of type). This is useful for designing more flexible systems.
	#Interface: Fields are implicitly public, static, and final.

## Anonymous class:-An anonymous class in Java is a type of inner class that doesn't have a name and is declared and instantiated all in one place

	eg.

	interface Animal {
    	void makeSound();
	}


	public class Main {
		public static void main(String[] args) {
			// Anonymous class implementing Animal interface
			Animal dog = new Animal() {
				@Override
				public void makeSound() {
					System.out.println("Bark");
				}
			};
			
			dog.makeSound(); // Output: Bark
		}
	}

	**The anonymous class is created and instantiated when new Animal() is called.
	Limitations of Anonymous Classes:
		Cannot Have Constructors:- Since anonymous classes don't have a name, you cannot define a constructor explicitly.
	

	## Function Interface
		A functional interface in Java is an interface that contains exactly one abstract method. Functional interfaces are a key feature in Java, especially with the introduction of lambda expressions in Java 8

		Lambda Expressions: Functional interfaces can be implemented using lambda expressions, which allow for more concise and readable code
		eg.

		@FunctionalInterface
		interface Calculator {
			int calculate(int a, int b); // Single abstract method
		}

		public class Main {
			public static void main(String[] args) {
				// Using a lambda expression to implement the Calculator interface
				Calculator addition = (a, b) -> a + b;
				Calculator subtraction = (a, b) -> a - b;

				// Calling the calculate method
				System.out.println("Addition: " + addition.calculate(5, 3));   // Output: 8
				System.out.println("Subtraction: " + subtraction.calculate(5, 3)); // Output: 2
			}
		}

## Stack and Heap Memory

		Stack Memory: Used for method execution and local variable storage, it's fast, limited in size, and tied to the method's lifecycle. It's managed automatically by the JVM, and each thread has its own stack.

		* Each time a method is called, a new block (or frame) is created in the stack memory, and this block contains information about method arguments, local variables, and the return address
				 When a method is finished, its associated stack frame is automatically removed.
		
		Example: Local variables and method calls are stored in stack memory.

		public class StackExample {
			public static void main(String[] args) {
				int x = 10; // 'x' is stored in stack memory
				int y = 20; // 'y' is stored in stack memory
				int result = add(x, y); // The method call and local variables are stored in the stack
				System.out.println(result);
			}

			public static int add(int a, int b) {
				int sum = a + b; // 'sum' is stored in stack memory
				return sum;
			}
		}


		Heap Memory: Used for dynamic memory allocation of objects, it's larger, slower, and managed by Java's garbage collector. It's shared among all threads, and objects remain in memory as long as they are reachable.
				Whenever you create a new object in Java (e.g., using new), the memory for that object is allocated from the heap.

		eg.

		public class HeapExample {
			public static void main(String[] args) {
				Person person = new Person("John", 25); // 'person' object is stored in heap memory
				System.out.println(person.getName());
			}
		}

		class Person {
			private String name;  // 'name' is stored in heap memory
			private int age;      // 'age' is stored in heap memory

			// Constructor
			public Person(String name, int age) {
				this.name = name;
				this.age = age;
			}
		}

##Object Class
		The Object class is the root of the class hierarchy. Every class in Java, either directly or indirectly, inherits from the Object class. This means that Object is the superclass of all other classes in Java. If a class doesn't explicitly extend another class, it implicitly extends the Object class.

		The Object class provides default implementations of methods like equals(), hashCode(), toString(), clone(), finalize(), and others, which can be overridden by subclasses to provide custom behavior.
		eg. Important method of Object Class

		@Override
		public boolean equals(Object obj) {
			if (this == obj) return true;
			if (obj == null || getClass() != obj.getClass()) return false;
			Person person = (Person) obj;
			return age == person.age && Objects.equals(name, person.name);
		}

##PolyMorphisim

		PolyMorphisim allows us to perform single action in different ways. In the other words, polymorphisim allow us to define one interface and have multiple implementation.

		Types of Polymorphism in Java

		1. Compile-time Polymorphism (Method Overloading)
				The correct method to call is determined at compile time based on the number and type of arguments passed to the method.
							or,
				The method to call is chosen at compile time based on the number and type of arguments.

				public class Calculator {
					// Overloaded method for adding two integers
					public int add(int a, int b) {
						return a + b;
					}

					// Overloaded method for adding three integers
					public int add(int a, int b, int c) {
						return a + b + c;
					}

					// Overloaded method for adding two doubles
					public double add(double a, double b) {
						return a + b;
					}

					public static void main(String[] args) {
						Calculator calc = new Calculator();
						System.out.println(calc.add(2, 3));          // Calls the first method
						System.out.println(calc.add(2, 3, 4));       // Calls the second method
						System.out.println(calc.add(2.5, 3.5));      // Calls the third method
					}
				}

			2. Runtime Polymorphism (Method Overriding)
				The method that gets called is determined at runtime based on the actual object (not the reference type).
								or
				The method called is decided at runtime based on the actual object, not its type

				class Animal {
					// Superclass method
					public void sound() {
						System.out.println("Animal makes a sound");
					}
				}

				class Dog extends Animal {
					// Subclass method overriding the superclass method
					@Override
					public void sound() {
						System.out.println("Dog barks");
					}
				}

				public class Main {
					public static void main(String[] args) {
						Animal myAnimal = new Animal();  // Animal reference and object
						Animal myDog = new Dog();        // Animal reference but Dog object

						myAnimal.sound();  // Outputs: Animal makes a sound
						myDog.sound();     // Outputs: Dog barks
					}
				}











	












