##Exception Handling
    An exception is an event that occurs during the execution of a program that disrupts the normal flow of instructions.
                    or,
    An exception is an event that interrupts a program's normal flow.

    #Types of Exceptions
    1.Checked Exceptions: These are exceptions that are checked at compile-time. The compiler forces the programmer to handle these exceptions. For example, IOException, SQLException.
                    or,
        Checked exceptions are errors the compiler requires you to handle during compile-time.

    2.Unchecked Exceptions (Runtime Exceptions): These exceptions occur at runtime and are not checked at compile-time. They are typically the result of programming errors, such as logic mistakes. For example, ArithmeticException, NullPointerException.

            or,
        Runtime exceptions happen during program execution and aren't checked at compile-time, often caused by programming errors.

    #Key Components of Exception Handling

    1.try block: The code that might throw an exception is placed inside the try block.

    2.catch block: The catch block is used to handle the exception.

    3.finally block: The finally block is always executed, whether an exception is thrown or not. It's typically used to release resources like closing files, releasing database connections, etc.
        *(condition in finally not executed:- when we use System.exit() before finally block || exception occur in finally block)

    4.throw keyword: The throw keyword is used to explicitly throw an exception.

    5.throws keyword: The throws keyword is used in a method's signature to declare that the method can throw one or more exceptions.
                    or,
            The throws keyword is used in a method to say it might cause certain exceptions.


    eg.

    public class ExceptionExample {
        public static void main(String[] args) {
            try {
                int[] numbers = {1, 2, 3};
                System.out.println(numbers[3]); // This will throw an ArrayIndexOutOfBoundsException
            } catch (ArrayIndexOutOfBoundsException e) {
                System.out.println("Array index is out of bounds! " + e.getMessage());
            } finally {
                System.out.println("This block always executes.");
            }
        }
    }

    OUTPUT:-
        Array index is out of bounds! 3
        This block always executes.


    #Custom Exception

    class InvalidAgeException extends Exception {
        public InvalidAgeException(String message) {
            super(message);
        }
    }

    public class CustomExceptionExample {
        public static void main(String[] args) {
            try {
                validateAge(15);
            } catch (InvalidAgeException e) {
                System.out.println("Exception caught: " + e.getMessage());
            }
        }

        public static void validateAge(int age) throws InvalidAgeException {
            if (age < 18) {
                throw new InvalidAgeException("Age must be 18 or older.");
            } else {
                System.out.println("Valid age.");
            }
        }
    }


## Boxing and Unboxing

Boxing and unboxing in Java refer to the automatic conversion between primitive data types (like int, char, etc.) and their corresponding wrapper class objects (like Integer, Character, etc.).

What is Boxing?
    Boxing is the process of converting a primitive data type into its corresponding wrapper class object.

    eg.
    int num = 10; // Primitive type
    Integer boxedNum = num; // Boxing: converting int to Integer

What is Unboxing?
    Unboxing is the reverse process of boxing. It involves converting an object of a wrapper class back to its corresponding primitive data type.
    eg.

    Integer boxedNum = 10; // Boxing: converting int to Integer
    int num = boxedNum; // Unboxing: converting Integer to int

##IMPORTANT POINTS
    *collections like ArrayList can only store objects (not primitives)

    *Null Pointer Exception: Unboxing a null object will throw a NullPointerException.
        eg.
        Integer boxedNum = null;
        int num = boxedNum; // This will throw a NullPointerException

    *Equality Check: Be cautious while comparing primitive and wrapper types.
        eg.
        Integer a = 100;
        Integer b = 100;
        System.out.println(a == b); // true, due to caching of Integer values in the range -128 to 127

        Integer c = 200;
        Integer d = 200;
        System.out.println(c == d); // false, different objects for values outside the cached range

    *Object Identity vs. Value Equality: Use .equals() for value comparison rather than ==, which checks for object identity.

    ##Java collection Framework

    *addAll() =add element list.addAll(set) etc.

    *list.toArray() = convert list to Array

    * indexOf() = to find index

    *** List<String> fruits=new ArrayList<>();
        fruits.add("Kiwi);
        fruits.add("Mango");

        Iterator<String>fe=fruits.iterator();
        while(fe.hasNext())
            System.out.println(fe.next()); //kiwi mango 


##Internal working of ArrayList

    *The initial capacity of the ArrayList is typically set to 10

    *Resizing:-When the ArrayList reaches its capacity, it resizes itself. This involves creating a new, larger array and copying the elements from the old array to the new one. The new size is often 1.5 to 2 times the old size.

##LinkedList
        A LinkedList in Java is different from an ArrayList in how it stores and manages elements. Instead of using a contiguous block of memory like an array, a LinkedList uses a series of nodes, each of which contains a reference to the next node in the list (and optionally the previous node for a doubly linked list)

##ArrayDeque
    ArrayDeque in Java is a resizable-array implementation of the Deque (double-ended queue) interface. It is a versatile data structure that allows elements to be added or removed from both ends efficiently. Due to its array-based nature, it provides fast operations compared to LinkedList, especially for operations at both ends of the deque.

    eg.

    import java.util.ArrayDeque;
    import java.util.Deque;

    public class ArrayDequeExample {
        public static void main(String[] args) {
            Deque<String> deque = new ArrayDeque<>();

            // Adding elements at the end
            deque.add("Apple");
            deque.addLast("Banana");  // Same as deque.add("Banana")

            // Adding elements at the front
            deque.addFirst("Orange");

            // Accessing elements
            System.out.println("First Element: " + deque.getFirst());  // Output: Orange
            System.out.println("Last Element: " + deque.getLast());    // Output: Banana

            // Removing elements
            deque.removeFirst();  // Removes "Orange"
            deque.removeLast();   // Removes "Banana"

            // Final deque state
            System.out.println("Final Deque: " + deque); // [Apple]
        }
    }

    *ArrayDeque is more memory-efficient than LinkedList since it does not require storing additional pointers for each element.

    Disadvantages:

    1.Not Thread-Safe: Requires external synchronization if used in a concurrent environment.
    2.No Null Elements: Does not support null values, which might be limiting in some use cases.

## set
    HashSet<>() //O(1)
    LinkedHashSet<>() // O(n)
    TreeSet<>()  // O(logn)

#Map
    ArrayList<String>keys=new ArrayList<>(map.keySet()); //convert set into list

    collection<String> values=map.values();

##Sorting
    collections.sort(list);

    people.sort((a, b) -> {
        // Compare by age first
        int ageComparison = Integer.compare(a.age, b.age);
            
        // If ages are equal, compare by name
        if (ageComparison == 0) {
            return a.name.compareTo(b.name);
        }
            
        // Otherwise, return the age comparison result
        return ageComparison;
    });

    PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> {
                if (a.val != b.val) {
                    return Integer.compare(a.val, b.val);
                }
                    return Integer.compare(a.index, b.index);
                });

    list.sort((a, b) -> {
            int freqA = map.get(a);
            int freqB = map.get(b);
            if (freqA != freqB) {
                return freqB - freqA; // Higher frequency comes first
            } else {
                return a - b; // If frequencies are the same, smaller value comes first
            }
        });




