1. when do we use ArrayList<ArrayList<Integer>> and Map<Integer<List<Integer>> for build graph.

1️⃣ ArrayList<ArrayList<Integer>>
    ArrayList<ArrayList<Integer>> graph = new ArrayList<>();

    -> Each index in the outer list represents a node.
    -> The inner list at each index stores the neighbors of that node.

✅ When to Use?
    ✔ Graph nodes are numbered from 0 to N-1
    ✔ Fixed number of nodes (N) is known beforehand
    ✔ Memory efficiency is important
    ✔ Dense graphs (where many nodes exist and are numbered sequentially)

    code:- 
    for (int i = 0; i < n; i++) {
        graph.add(new ArrayList<>());
    }

    // Add edges (undirected graph)
    graph.get(0).add(1);
    graph.get(1).add(0);

    Pros:-
    Better for competitive programming, where N is predefined.
    Faster access (O(1)) to a node’s neighbors using graph.get(node).

    cons:-
    ❌ Doesn’t work well for sparse graphs (large node indices but fewer connections).
    ❌ Cannot handle dynamic graphs well where nodes are arbitrary (e.g., IDs like 100, 500, 999).

2️⃣ Map<Integer, List<Integer>>
    Map<Integer, List<Integer>> graph = new HashMap<>();

    -> Keys represent nodes, which can be any arbitrary integer (not necessarily from 0 to N-1).
    -> Values store lists of neighboring nodes.

✅ When to Use?
    ✔ Graph has arbitrary node values (e.g., user IDs, large index gaps)
    ✔ Sparse graphs where nodes are not sequential
    ✔ Dynamic graphs (new nodes can be added without wasting space)
    ✔ Better for large constraints where N is unknown initially

    // Add edges
    graph.computeIfAbsent(100, k -> new ArrayList<>()).add(200);
    graph.computeIfAbsent(200, k -> new ArrayList<>()).add(100);

    Pros:-
    ✅ Can handle graphs where nodes are non-sequential (e.g., user IDs, large gaps in indices).


Dynamic graph (adding/removing nodes) :- use Map
Nodes are numbered from 0 to N-1 :- use List
Nodes are arbitrary (e.g., 100, 500, 999) : use map 