1. when do we use ArrayList<ArrayList<Integer>> and Map<Integer<List<Integer>> for build graph.

    1ï¸âƒ£ ArrayList<ArrayList<Integer>>
        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();

        -> Each index in the outer list represents a node.
        -> The inner list at each index stores the neighbors of that node.

    âœ… When to Use?
        âœ” Graph nodes are numbered from 0 to N-1
        âœ” Fixed number of nodes (N) is known beforehand
        âœ” Memory efficiency is important
        âœ” Dense graphs (where many nodes exist and are numbered sequentially)

        code:- 
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
        }

        // Add edges (undirected graph)
        graph.get(0).add(1);
        graph.get(1).add(0);

        Pros:-
        Better for competitive programming, where N is predefined.
        Faster access (O(1)) to a nodeâ€™s neighbors using graph.get(node).

        cons:-
        âŒ Doesnâ€™t work well for sparse graphs (large node indices but fewer connections).
        âŒ Cannot handle dynamic graphs well where nodes are arbitrary (e.g., IDs like 100, 500, 999).

    2ï¸âƒ£ Map<Integer, List<Integer>>
        Map<Integer, List<Integer>> graph = new HashMap<>();

        -> Keys represent nodes, which can be any arbitrary integer (not necessarily from 0 to N-1).
        -> Values store lists of neighboring nodes.

    âœ… When to Use?
        âœ” Graph has arbitrary node values (e.g., user IDs, large index gaps)
        âœ” Sparse graphs where nodes are not sequential
        âœ” Dynamic graphs (new nodes can be added without wasting space)
        âœ” Better for large constraints where N is unknown initially

        // Add edges
        graph.computeIfAbsent(100, k -> new ArrayList<>()).add(200);
        graph.computeIfAbsent(200, k -> new ArrayList<>()).add(100);

        Pros:-
        âœ… Can handle graphs where nodes are non-sequential (e.g., user IDs, large gaps in indices).


    Dynamic graph (adding/removing nodes) :- use Map
    Nodes are numbered from 0 to N-1 :- use List
    Nodes are arbitrary (e.g., 100, 500, 999) : use map 

2.  When to Use Kahn vs DFS ? 
    Asked explicitly for BFS-based approach	
    You want topological order as well	
    You want to avoid recursion (stack overflow)	
    Graph is very large, and you're worried about DFS stack

3. What is Topological Sorting?
    A linear ordering of vertices such that for every edge u â†’ v, u comes before v in the ordering.
    So it only applies to a Directed Acyclic Graph (DAG).

4.  â€œBipartiteâ€ means
    A graph is bipartite if we can color it using two colors such that no two adjacent nodes have the same color.
    Another way: A graph is bipartite if it does not contain any odd-length cycle.

5. Bellmon Ford Algorithm 
    Repeat the edge relaxation process (V - 1) times
    Because the longest possible shortest path can have at most V - 1 edges.
    After that, all shortest paths should be finalized.

6. All Pair shortest path
    Dijkstra: Run V times for APSP â†’ O(V Ã— E log V)
    Bellman-Ford: O(VÂ² Ã— E) if done for all pairs
    Floyd-Warshall: O(VÂ³) â†’ simpler and often better for dense graphs

    why K in outer loop not in inner loop ?
        At step k, we consider all paths that can go through node k.
        All updates to dist[i][j] are based on using nodes {0, 1, ..., k} as intermediate nodes.

    If You Write k in the Inner Loop:
        1. You're not building the solution step by step.
            Youâ€™re trying all k for each i and j, but without ensuring the results from previous k values are already finalized.
            So some paths might use future intermediate nodes that haven't been processed yet.
    ğŸ” Real Analogy
    Suppose youâ€™re planning train trips from city i to city j:
        You decide: â€œIâ€™ll first see if I can go through station 0, then through station 1, and so on.â€
        That means: outer loop must be the station k you're trying to insert between every pair (i, j).

    If you do k inside, itâ€™s like:
        â€œTry all possible in-between stations at once, without caring about order or progress,â€ which breaks the structure of the shortest-path updates.

7. You have two standard MST algorithms:
    Prim's Algorithm (Priority Queue + Visited Array)
    Kruskalâ€™s Algorithm (Sorting + Disjoint Set)

    Prim's : Multiple same-weight edges? Doesnâ€™t affect correctness; min weight is always chosen.

