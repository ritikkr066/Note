            BACKTRACKING
1. Definition:
        # Backtracking is a problem-solving approach where you try to build a solution incrementally and backtrack as soon as you realize the current path won't yield a solution.

        # It’s commonly used for problems that require searching through all possible solutions.

Algorithm Template(Pseudocode)

void backtrack(State currentState) {
    if (solutionFound(currentState)) {
        // Process the solution
        return;
    }
    for (Option option : validOptions(currentState)) {
        applyOption(currentState, option); // Make the choice
        backtrack(currentState); // Recurse
        undoOption(currentState, option); // Undo the choice (backtrack)
    }
}


			Interview Question-1 (N-Queen)

Explaining the Approach for the N-Queens Problem

    1.Problem Understanding:
        -> Start by explaining the problem in simple terms:
                "The N-Queens problem is about placing N queens on an N x N chessboard so that no two queens attack each other. A queen can attack horizontally, vertically, and diagonally."

        -> Mention the goal:
                "We need to find all possible configurations where queens are placed safely on the board."
    
    2.Approach (Backtracking):
        -> State the general idea of backtracking:
                "Backtracking is a trial-and-error approach where we place a queen on the board, and if the placement leads to a valid solution, we continue; otherwise, we backtrack and try the next possibility."
        
        -> Highlight the recursive nature:
                "The solution is built row by row. For each row, we try placing a queen in every column and check if it is safe using the isValid function. If it is safe, we place the queen and proceed to the next row. If not, we backtrack by removing the queen and trying the next column."

    3.Detailed Code Walkthrough:
        Divide your explanation into three key parts:
        -> Initialization:
                "We start by initializing an empty board represented as a list of strings, where each string represents a row. Initially, all cells are marked with '.' to indicate that they are empty."
        
        -> Recursive Function (solve):
                "The solve function is called recursively to place queens row by row. If we reach a row beyond the last one, it means we have successfully placed queens in all rows, so we add the current configuration to the result." "For each row, we iterate through all columns. If placing a queen in a column is valid (isValid function), we update the board, make a recursive call to place queens in the next row, and then backtrack by removing the queen."
        
        -> Validation (isValid Function):
                "The isValid function checks three conditions to ensure a queen's placement is safe:
                    No other queen is in the same column.
                    No other queen is in the left diagonal.
                    No other queen is in the right diagonal."
        
        -> Complexity Analysis:
                Time Complexity:
                    "The time complexity is approximately O(N!) because we have N choices for the first row, N−1 for the second, N−2 for the third, and so on."

                Space Complexity:
                    "The space complexity is O(N^2) for the board representation and the recursion stack."

