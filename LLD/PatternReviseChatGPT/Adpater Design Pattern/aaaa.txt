â€œHow do you make two incompatible interfaces work together?â€
    Adapter Pattern converts the interface of a class into another interface that the client expects

2ï¸âƒ£ Problem It Solves (Why we need it)
    You have:
    Existing code (client)
    Third-party / legacy class
    Interfaces donâ€™t match
    âŒ You cannot modify either
    âœ… Adapter acts as a bridge

3ï¸âƒ£ Real-World Analogy (Easy Recall)
    Charger adapter ğŸ”‹
    Plug â‰  Socket â†’ Adapter makes them compatible

4ï¸âƒ£ Structure
Client â†’ Target Interface
              â†‘
           Adapter
              â†‘
         Adaptee (existing class)


5ï¸âƒ£ Now explain that line step-by-step
    new PayPalService()
    âœ” Creates PayPalâ€™s object
    âœ” This class is not compatible with PaymentGateway

    new PayPalAdapter(new PayPalService())
    âœ” Creates adapter
    âœ” Injects PayPalService into it
    âœ” Adapter wraps PayPalService
    âœ” Adapter becomes compatible with PaymentGateway

    PaymentGateway gateway =
        new PayPalAdapter(new PayPalService());
    gateway.pay(500);
    Your system talks to PaymentGateway
    Adapter talks to PayPal
    PayPal remains unchanged

6ï¸âƒ£ Why not create PayPalService inside Adapter?
    class PayPalAdapter {
        PayPalAdapter() {
            this.payPalService = new PayPalService(); // âŒ
        }
    }

    Problems:
        Adapter tightly coupled to PayPal
        Cannot mock/test
        Cannot swap implementation
        Violates Dependency Inversion
        Passing it in constructor = dependency injection âœ…

class PayPalAdapter implements PaymentGateway {
    private PayPalService payPalService;   // PayPalAdapter HAS a PayPalService
}
