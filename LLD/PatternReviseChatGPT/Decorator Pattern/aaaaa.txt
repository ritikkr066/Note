Decorator Pattern dynamically adds new behavior to an object by wrapping it, without modifying its class.

A decorator â€œis-aâ€ component and also â€œhas-aâ€ component

Structure
    Component (interface)
    |
    ConcreteComponent
    |
    Decorator (abstract)  ---> wraps Component
    |
    ConcreteDecorators

#Decorator enhances behavior; Strategy changes behavior.

Decorator Pattern allows adding new functionality to an object dynamically by wrapping it. It avoids subclass explosion and follows Open-Closed Principle using composition.

Coffee coffee =
    new SugarDecorator(
        new MilkDecorator(
            new SimpleCoffee()
        )
    );

2ï¸âƒ£ Two different phases (this is the key insight)
    ğŸŸ¦ Phase 1: Object creation (INSIDE â†’ OUTSIDE)
    This happens at construction time.
    Creation order:
        new SimpleCoffee()
        â†’ new MilkDecorator(SimpleCoffee)
        â†’ new SugarDecorator(MilkDecorator)
    Creation works from inside to outside

    ğŸŸ© Phase 2: Method execution (OUTSIDE â†’ INSIDE â†’ OUTSIDE)
    This happens when you call a method. // coffee.cost();

        SugarDecorator.cost()
            â†’ MilkDecorator.cost()
                â†’ SimpleCoffee.cost()
            â† MilkDecorator adds cost
        â† SugarDecorator adds cost
    
    Execution:
    SugarDecorator says:
    ğŸ‘‰ â€œLet me ask inner coffee firstâ€
    MilkDecorator says:
    ğŸ‘‰ â€œLet me ask inner coffee firstâ€
    SimpleCoffee returns 50
    MilkDecorator adds +10 â†’ 60
    SugarDecorator adds +5 â†’ 65
    âœ” Final result: 65

    coffee.getDescription();
    //Execution
        Sugar â†’ Milk â†’ Simple
        Simple returns "Simple Coffee"
        Milk adds ", Milk"
        Sugar adds ", Sugar"
    
    //Result
        "Simple Coffee, Milk, Sugar"
