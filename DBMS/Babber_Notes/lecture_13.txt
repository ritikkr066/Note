Q: How to implement Atomicity and Durability in Transactions ? 
    To ensure atomicity and durability in a DBMS, the system uses mechanisms like the shadow-copy scheme and log-based recovery. The shadow-copy approach works by maintaining a pointer to the current copy of the database on disk. When a transaction begins, it creates a complete copy of the database, and all changes are made to this new copy. The original (shadow) copy remains untouched. If the transaction fails or needs to abort, the new copy is simply discarded, ensuring atomicity—either all updates are made or none. If the transaction commits successfully, the system first writes all changes to disk and then atomically updates the pointer to point to the new copy. This guarantees durability, because if a crash happens after the pointer update, the changes persist; if it happens before, the old copy is still intact. However, this approach is inefficient since it copies the entire database for every transaction, and hence it’s rarely used in practice.

    A more practical method is log-based recovery, where every change is first recorded in a log stored in stable storage. This log helps the system recover in case of a crash. There are two main strategies here: deferred and immediate modification. In deferred modification, all database writes are delayed until the transaction is ready to commit. The changes are logged during execution, and only when the transaction commits are they applied to the actual database. This makes rollback simple—if the system crashes before commit, we can ignore the logs. In contrast, immediate modification allows changes to be applied during transaction execution. However, every change is logged beforehand, so if a crash happens, we can undo uncommitted changes using the old values and redo committed changes using the new ones. This method supports both undo and redo operations and is more complex but also more efficient and scalable for systems handling multiple concurrent transactions.